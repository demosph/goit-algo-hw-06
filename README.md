# Графи

## Завдання 1

Створіть граф за допомогою бібліотеки **networkX** для моделювання певної реальної мережі (наприклад, транспортної мережі міста, соціальної мережі, інтернет-топології).
Візуалізуйте створений граф, проведіть аналіз основних характеристик (наприклад, кількість вершин та ребер, ступінь вершин).

### Результати виконання:

````
Number of nodes: 6
Number of edges: 8
Degree of node 1: 2
Degree of node 2: 3
Degree of node 3: 3
Degree of node 4: 2
Degree of node 5: 4
Degree of node 6: 2
Average degree: 1.3333333333333333
````

## Завдання 2

Напишіть програму, яка використовує алгоритми DFS і BFS для знаходження шляхів у графі, який було розроблено у першому завданні.
Далі порівняйте результати виконання обох алгоритмів для цього графа, висвітлить різницю в отриманих шляхах. Поясніть, чому шляхи для алгоритмів саме такі.

### Висновки:

Результати виконання DFS та BFS для даного графа вказують на різні принципи обходу та знаходження шляхів у графі.

**DFS** (глибокий пошук):
  - Перші два шляхи, **[1, 2, 4, 5, 6]** та **[1, 2, 4, 5, 3, 6]**, обидва проходять через вершину 4, але різними шляхами доходять до вершини 6.
  - Ще два шляхи, **[1, 2, 5, 6]** та **[1, 2, 5, 3, 6]**, обидва проходять через вершину 5, але різними шляхами доходять до вершини 6.
  - Останні два шляхи, **[1, 3, 6]** та **[1, 3, 5, 6]**, проходять через вершину 3 та вершину 5, відповідно.

**BFS** (широкий пошук):
  - Єдиний шлях, **[1, 3, 6]**, який є найкоротшим за кількістю ребер, враховуючи шляхи з усіх можливих.

Різниця в отриманих шляхах зумовлена тим, як працюють самі алгоритми:

1. **DFS** (глибокий пошук) обходить граф, спускаючись глибше вглиб, перевіряючи всі гілки, і тому може знаходити більше альтернативних шляхів.
2. **BFS** (широкий пошук) обходить граф пошарово, і він шукає найдовший шлях на кожному рівні графа, тому виводить лише найкоротші шляхи.

У нашому випадку **DFS** може знайти багато шляхів, які включають вершини 4 та 5, але лише один з цих шляхів є найкоротшим (використовуючи **BFS**).

Це демонструє важливість вибору алгоритму відповідно до конкретних потреб і властивостей графа. У випадках, коли важливо знайти найкоротший шлях, **BFS** може бути більш відповідним вибором.

## Завдання 3

Реалізуйте алгоритм Дейкстри для знаходження найкоротшого шляху в розробленому графі: додайте у граф ваги до ребер та знайдіть найкоротший шлях між всіма вершинами графа.

### Результати виконання:
````
Shortest paths from 1: {1: [1], 2: [1, 2], 3: [1, 3], 4: [1, 2, 4], 5: [1, 2, 5], 6: [1, 3, 6]}
Shortest paths from 2: {2: [2], 1: [2, 1], 4: [2, 4], 5: [2, 5], 3: [2, 1, 3], 6: [2, 5, 6]}
Shortest paths from 3: {3: [3], 1: [3, 1], 6: [3, 6], 5: [3, 5], 2: [3, 1, 2], 4: [3, 5, 4]}
Shortest paths from 4: {4: [4], 2: [4, 2], 5: [4, 5], 1: [4, 2, 1], 6: [4, 5, 6], 3: [4, 5, 3]}
Shortest paths from 5: {5: [5], 2: [5, 2], 4: [5, 4], 6: [5, 6], 3: [5, 3], 1: [5, 2, 1]}
Shortest paths from 6: {6: [6], 3: [6, 3], 5: [6, 5], 1: [6, 3, 1], 2: [6, 5, 2], 4: [6, 5, 4]}
````